# 前 K 个高频元素，解题思路
* 思路：hash分片 + 堆排序
* 解题过程
1. 频率计算：
   * 使用 std::unordered_map<int, int> 来记录每个元素数字、出现的频率。
2. 优先队列（最小堆）：
   * 使用 std::priority_queue 最小堆来存储频率最高的 k 个元素。
   * 使用一个 lambda 函数来定义堆的比较规则，这里按照频率排序。
```
   // 使用 lambda 表达式创建最小堆
   std::priority_queue<int, std::vector<int>, decltype([](int a, int b) { return a > b; })> pq([](int a, int b) {
       return a > b; // 注意这里的比较方式，使 a > b 表示 a 的优先级低于 b
   });
```
3. 结果提取：
   * 遍历 freqMap，将元素添加到堆中。如果堆的大小超过 k，则弹出频率最小的元素。
4. 最后从堆中提取结果，并反转以得到正确的顺序。

* 其他补充
  * 桶排序的核心理念：将数据分到几个有序的桶里，每个桶里的数据再分别进行排序，最后依次合并各个桶中的数据，从而得到有序的数据序列。
  * 这个问题可以用 桶的思想和最小堆（或优先队列）来找出前K个高频元素

